# -*- coding: utf-8 -*-
"""Examen 18 Econometria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDIt0RZ419fEYuGID6peSnPuW7hLl9zS
"""

# Import required libraries
import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt

# Upload Excel file
print("Please upload PDI Excel file")
pdi_upload = files.upload()
pdi_filename = list(pdi_upload.keys())[0]
pdi_df = pd.read_excel(pdi_filename)

# Print available columns
print("\nPDI DataFrame columns:", list(pdi_df.columns))

# Ask user for the correct column name
close_column = input("Please enter the column name containing closing prices: ")

# Extract closing prices using user-specified column name
try:
    pdi_close = pdi_df[close_column]
except KeyError:
    print(f"Error: Column '{close_column}' not found in DataFrame")
    print("Please check the column names and try again")
    raise

# Function for unit root tests with interpretation
def unit_root_tests(series, name):
    print(f"\nUnit Root Tests for {name}:")

    # ADF Test
    adf_result = adfuller(series)
    print("ADF Test:")
    print(f'ADF Statistic: {adf_result[0]:.4f}')
    print(f'p-value: {adf_result[1]:.4f}')
    print(f'Critical Values: {adf_result[4]}')
    print("Interpretation:")
    if adf_result[1] < 0.05:
        print(f"  - p-value < 0.05: Reject null hypothesis - {name} is stationary")
    else:
        print(f"  - p-value >= 0.05: Fail to reject null - {name} may be non-stationary")

    # KPSS Test
    kpss_result = kpss(series)
    print("\nKPSS Test:")
    print(f'KPSS Statistic: {kpss_result[0]:.4f}')
    print(f'p-value: {kpss_result[1]:.4f}')
    print(f'Critical Values: {kpss_result[3]}')
    print("Interpretation:")
    if kpss_result[1] < 0.05:
        print(f"  - p-value < 0.05: Reject null hypothesis - {name} is non-stationary")
    else:
        print(f"  - p-value >= 0.05: Fail to reject null - {name} may be stationary")

# Perform unit root tests
unit_root_tests(pdi_close, "PDI")

# Function to plot correlograms with interpretation
def plot_correlograms(series, name, lags=30):
    plt.figure(figsize=(12, 8))

    plt.subplot(2, 1, 1)
    plot_acf(series, lags=lags, ax=plt.gca())
    plt.title(f'ACF for {name}')

    plt.subplot(2, 1, 2)
    plot_pacf(series, lags=lags, ax=plt.gca())
    plt.title(f'PACF for {name}')

    plt.tight_layout()
    plt.show()

    print(f"\nCorrelogram Interpretation for {name}:")
    print("  - ACF: Shows total correlation at each lag, including indirect effects")
    print("  - PACF: Shows direct correlation at each lag, controlling for earlier lags")
    print("  - Significant spikes outside the blue confidence interval suggest strong correlations")
    print("  - ACF decay pattern indicates potential ARIMA model orders")
    print("  - PACF cutoff suggests AR order, while ACF cutoff suggests MA order")

# Plot correlograms for original series
plot_correlograms(pdi_close, "PDI Original")

# Difference the series
pdi_diff = pdi_close.diff().dropna()

# Plot correlograms for differenced series
plot_correlograms(pdi_diff, "PDI Differenced")

# Note: Cointegration test is not applicable for a single time series. Skipping this section.

# Function to find best ARIMA model with interpretation (includes ARMA when d=0)
def find_best_arima(series, name, max_p=3, max_d=2, max_q=3):
    best_aic = float('inf')
    best_order = None

    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, d, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                except:
                    continue

    print(f"\nBest ARIMA/ARMA model for {name}:")
    print(f"Order: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    print("Interpretation:")
    print(f"  - p={best_order[0]}: {best_order[0]} autoregressive term(s)")
    print(f"  - d={best_order[1]}: {best_order[1]} difference(s) needed for stationarity (d=0 indicates ARMA)")
    print(f"  - q={best_order[2]}: {best_order[2]} moving average term(s)")
    return best_order

# Find and fit best ARIMA model
pdi_order = find_best_arima(pdi_close, "PDI")

# Fit final ARIMA model
pdi_model = ARIMA(pdi_close, order=pdi_order).fit()

# Forecast next 1 period (single value)
forecast_steps = 1
pdi_forecast = pdi_model.forecast(steps=forecast_steps)

# Create forecast index
last_index = len(pdi_close) - 1
forecast_index = range(last_index + 1, last_index + 1 + forecast_steps)

# Plot original series with forecast
plt.figure(figsize=(12,6))
plt.plot(pdi_close, label='PDI Historical')
plt.plot(forecast_index, pdi_forecast, label='PDI Forecast', color='red', marker='o')
plt.title('PDI Closing Prices with Forecast')
plt.legend()
plt.show()

# Detailed forecast plot with confidence intervals and interpretation
def plot_forecast(model, series, name, steps=1):
    forecast_obj = model.get_forecast(steps=steps)
    forecast = forecast_obj.predicted_mean
    conf_int = forecast_obj.conf_int()

    forecast_index = range(len(series), len(series) + steps)

    plt.figure(figsize=(12,6))
    plt.plot(series, label=f'{name} Historical')
    plt.plot(forecast_index, forecast, label='Forecast', color='red', marker='o')
    plt.fill_between(forecast_index,
                    conf_int.iloc[:, 0],
                    conf_int.iloc[:, 1],
                    color='pink',
                    alpha=0.3,
                    label='95% Confidence Interval')
    plt.title(f'{name} Price Forecast')
    plt.legend()
    plt.show()

    # Forecast interpretation
    last_value = series.iloc[-1]
    forecast_value = forecast.iloc[0]
    print(f"\nForecast Interpretation for {name}:")
    print(f"Last observed value: {last_value:.2f}")
    print(f"Forecast value: {forecast_value:.2f}")
    print(f"Forecast change: {forecast_value - last_value:.2f}")
    if forecast_value > last_value:
        print("Trend: Upward forecast")
    elif forecast_value < last_value:
        print("Trend: Downward forecast")
    else:
        print("Trend: Flat forecast")
    print(f"95% CI for forecast: [{conf_int.iloc[0, 0]:.2f}, {conf_int.iloc[0, 1]:.2f}]")
    print("Interpretation: The wider the confidence interval, the less certain the forecast")

# Generate detailed forecast plot and interpretation
plot_forecast(pdi_model, pdi_close, "PDI")

# Plot correlograms for model residuals
plot_correlograms(pdi_model.resid, "PDI ARIMA Residuals")

# Print the single forecast value
print("\nPDI Single Forecast Value:")
print(pdi_forecast.iloc[0])

# --------------------------------------------------------------
# 1. Install helpers (run once)
# --------------------------------------------------------------
!pip install -q pygments matplotlib

import io, base64, sys, os
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
import matplotlib.pyplot as plt
from google.colab import files

# --------------------------------------------------------------
# 2. Upload your .py script
# --------------------------------------------------------------
print("Upload the .py file that contains the PDI analysis")
uploaded = files.upload()
py_file = list(uploaded.keys())[0]               # e.g. "pdi_analysis.py"

# --------------------------------------------------------------
# 3. Capture stdout + all figures
# --------------------------------------------------------------
old_stdout = sys.stdout
sys.stdout = mystdout = io.StringIO()

# Store every figure that is created
fig_buffer = []

def capture_figures():
    for i in plt.get_fignums():
        fig = plt.figure(i)
        buf = io.BytesIO()
        fig.savefig(buf, format='png', bbox_inches='tight', dpi=150)
        buf.seek(0)
        fig_buffer.append(base64.b64encode(buf.read()).decode())
        plt.close(fig)

# Monkey-patch plt.show() so that we keep the image
_original_show = plt.show
def new_show(*args, **kwargs):
    capture_figures()
    return _original_show(*args, **kwargs)
plt.show = new_show

# --------------------------------------------------------------
# 4. Execute the script
# --------------------------------------------------------------
with open(py_file) as f:
    code = f.read()

exec(code)                     # <-- your PDI analysis runs here
capture_figures()              # catch any figure left open

stdout_text = mystdout.getvalue()
sys.stdout = old_stdout

# --------------------------------------------------------------
# 5. Build HTML
# --------------------------------------------------------------
lexer = PythonLexer()
formatter = HtmlFormatter(style='solarized-light', linenos=True)
highlighted_code = highlight(code, lexer, formatter)

# Embed captured figures
plot_html = ""
for b64 in fig_buffer:
    plot_html += f'<div class="plot"><img src="data:image/png;base64,{b64}"></div>\n'

result_html = f"""
<!DOCTYPE html>
<html><head><meta charset="utf-8">
<title>PDI Analysis Report</title>
<style>
  body{{font-family:Arial;margin:40px;background:#f9f9f9;}}
  h1{{color:#2c3e50;text-align:center;}}
  h2{{color:#2980b9;border-bottom:1px solid #ddd;padding-bottom:8px;}}
  pre{{background:#f4f4f4;padding:12px;border-radius:5px;overflow-x:auto;}}
  .plot{{text-align:center;margin:30px 0;}}
  .plot img{{max-width:100%;border:1px solid #ddd;border-radius:5px;}}
  .footer{{margin-top:50px;text-align:center;color:#7f8c8d;font-size:0.9em;}}
  {formatter.get_style_defs('.codehilite')}
</style>
</head><body>
<h1>PDI Time-Series Analysis Report</h1>
<p><strong>Script:</strong> <code>{py_file}</code></p>
<hr>

<h2>Code</h2>
{highlighted_code}

<h2>Console Output</h2>
<pre>{stdout_text}</pre>

<h2>Plots</h2>
{plot_html}

<div class="footer">
Generated on {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M')}
</div>
</body></html>
"""

# --------------------------------------------------------------
# 6. Save & download
# --------------------------------------------------------------
html_file = py_file.replace('.py', '_report.html')
with open(html_file, 'w', encoding='utf-8') as f:
    f.write(result_html)

print(f"\nReport ready: {html_file}")
files.download(html_file)